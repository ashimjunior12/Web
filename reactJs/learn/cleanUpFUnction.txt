import { useEffect } from "react";
import { useState } from "react";

const CleanupFunction = () => {

  const [name,setName]=useState(null);

  const handleClick = () =>{
    setName("roman");
  }
  const handleClickSecond = () =>{
    setName(null);
  }


  return (
    <div>
      {name ? (
        <div>
          <h2>Hello {name}</h2>
          <button className='btn' onClick={handleClickSecond}>
            click here
          </button>
          <DisplayMessage name={name}/>

        </div>
      ) : (
        <>
          <h2>hello world</h2>
          <button className='btn' onClick={handleClick}>
            click here
          </button>
        </>
      )}
    </div>
  );
};

  const DisplayMessage = ({ name }) => {

    useEffect(()=>{
      console.log('hello')
    },[])
    return <div className='alert alert-success'>hello {name}, welcome</div>;

  };
  



export default CleanupFunction;


=================================================================================================================================================================================================================

-    Initially, the CleanupFunction component renders and displays the "hello world" message and a button.
-    When you click the button (handleClick), the name state is updated to "roman," causing a re-render of the CleanupFunction component.
-    During the re-render, the DisplayMessage component is rendered again, triggering the useEffect within it.

Since the useEffect has an empty dependency array, it runs every time the DisplayMessage component is mounted or re-mounted. To avoid this behavior, you can either move the useEffect to the CleanupFunction component or use a React.memo or shouldComponentUpdate to prevent unnecessary re-renders of DisplayMessage.
